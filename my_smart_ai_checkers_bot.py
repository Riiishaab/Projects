# -*- coding: utf-8 -*-
"""My Smart AI Checkers Bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y9Z5UjOGGmiBKbHrnXCb0iDRPapbzqW_

# Import necessary libraries
"""

import random
from copy import deepcopy
import time
from IPython.display import display, HTML, Javascript
from ipywidgets import Output

"""# Define Constant and Pop Up Functions"""

# Define player colors
PLAYER1 = "#FF0000"  # Red
PLAYER2 = "#0000FF"  # Blue

# Create popup functionality for game notifications
notify_output = Output()
display(notify_output)

def popup(message):
    """Display a popup message in the notebook"""
    with notify_output:
        display(Javascript(f"""
            alert("{message}");
        """))

"""# Define Game Pieces and Board Structures"""

# Define the Piece class to represent checkers pieces
class Piece:
    def __init__(self, color, king=False):
        self.color = color  # Color of the piece
        self.king = king    # Whether the piece is a king

# Define the Square class to represent board squares
class Square:
    def __init__(self, piece=None):
        self.squarePiece = piece  # Piece on this square (or None)

# Define the Board class to represent the game board
class Board:
    def __init__(self):
        # Create an 8x8 grid of empty squares
        self.grid = [[Square() for _ in range(8)] for _ in range(8)]
        self.setup_board()

    def setup_board(self):
        """Set up the initial board with pieces in their starting positions"""
        # Place red pieces in the top three rows
        for row in range(3):
            for col in range(8):
                if (row + col) % 2 != 0:  # Only place on dark squares
                    self.grid[row][col] = Square(Piece(PLAYER1))

        # Place blue pieces in the bottom three rows
        for row in range(5, 8):
            for col in range(8):
                if (row + col) % 2 != 0:  # Only place on dark squares
                    self.grid[row][col] = Square(Piece(PLAYER2))

    def getSquare(self, x, y):
        """Get the square at the given coordinates"""
        if 0 <= x < 8 and 0 <= y < 8:
            return self.grid[y][x]
        return None

    def get_valid_legal_moves(self, x, y, continue_playing):
        """Get all valid moves for the piece at the given coordinates"""
        piece = self.getSquare(x, y).squarePiece
        if not piece:
            return []

        moves = []
        # Define movement directions based on piece color
        directions = [(1, 1), (-1, 1)] if piece.color == PLAYER1 else [(1, -1), (-1, -1)]
        # Kings can move in all four diagonal directions
        if piece.king:
            directions += [(1, -1), (-1, -1)] if piece.color == PLAYER1 else [(1, 1), (-1, 1)]

        # Check each direction for valid moves
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy
            if 0 <= new_x < 8 and 0 <= new_y < 8:
                # Check for simple move to empty square
                if not self.getSquare(new_x, new_y).squarePiece:
                    moves.append((new_x, new_y))
                # Check for jump over opponent's piece
                elif self.getSquare(new_x, new_y).squarePiece.color != piece.color:
                    jump_x, jump_y = new_x + dx, new_y + dy
                    if 0 <= jump_x < 8 and 0 <= jump_y < 8 and not self.getSquare(jump_x, jump_y).squarePiece:
                        moves.append((jump_x, jump_y))

        return moves

"""# Define Board Printing Functions"""

# Function to display the board with colored pieces
def print_board(board):
    """Display the board with colored pieces using HTML"""
    output = ""
    for row in board.grid:
        line = []
        for square in row:
            if square.squarePiece:
                if square.squarePiece.color == PLAYER1:
                    line.append('<span style="color:red">R</span>')
                else:
                    line.append('<span style="color:blue">B</span>')
            else:
                line.append('.')
        output += " ".join(line) + "<br>"
    display(HTML(output))

"""# Define Game Class"""

# Define the Game class to manage game state
class Game:
    def __init__(self):
        self.board = Board()
        self.current_turn = PLAYER1  # Red starts
        self.continue_playing = False
        self.move_count = 0

    def end_turn(self):
        """End the current turn and switch to the other player"""
        self.current_turn = PLAYER2 if self.current_turn == PLAYER1 else PLAYER1
        self.move_count += 1

    def is_game_over(self):
        """Check if the game is over"""
        # Game ends after 100 moves or if a player has no pieces left
        return self.move_count >= 100 or not self.get_player_pieces(PLAYER1) or not self.get_player_pieces(PLAYER2)

    def get_player_pieces(self, color):
        """Get all pieces of the given color"""
        pieces = []
        for y in range(8):
            for x in range(8):
                piece = self.board.getSquare(x, y).squarePiece
                if piece and piece.color == color:
                    pieces.append((x, y))
        return pieces

    def get_winner(self):
        """Determine the winner of the game"""
        if self.move_count >= 100:
            return "Draw - Move limit reached"
        p1_pieces = len(self.get_player_pieces(PLAYER1))
        p2_pieces = len(self.get_player_pieces(PLAYER2))
        if p1_pieces > p2_pieces:
            return "Smart AI (Red) wins!"
        elif p2_pieces > p1_pieces:
            return "Random AI (Blue) wins!"
        return "Draw!"

"""# My Smart AI Code"""

# Define the Smart AI player using minimax algorithm
class SmartAI:
    def __init__(self, color, game):
        self.color = color
        self.game = game
        self.opponent_color = PLAYER2 if color == PLAYER1 else PLAYER1

    def get_move(self, board):
        """Get the best move for the AI using minimax algorithm"""
        start_time = time.time()
        best_score = float('-inf')
        best_move = None
        pieces = self.game.get_player_pieces(self.color)

        # Evaluate each possible move
        for x, y in pieces:
            moves = board.get_valid_legal_moves(x, y, False)
            for move in moves:
                new_board = deepcopy(board)
                self._make_move(new_board, (x, y), move)
                # Use minimax to evaluate the move
                score = self._minimax(new_board, 3, False, float('-inf'), float('inf'))
                if score > best_score:
                    best_score = score
                    best_move = ((x, y), move)

        return best_move

    def _minimax(self, board, depth, maximizing, alpha, beta):
        """Minimax algorithm with alpha-beta pruning"""
        if depth == 0:
            return self._evaluate_board(board)

        if maximizing:
            max_eval = float('-inf')
            pieces = self.game.get_player_pieces(self.color)
            for x, y in pieces:
                moves = board.get_valid_legal_moves(x, y, False)
                for move in moves:
                    new_board = deepcopy(board)
                    self._make_move(new_board, (x, y), move)
                    eval = self._minimax(new_board, depth - 1, False, alpha, beta)
                    max_eval = max(max_eval, eval)
                    alpha = max(alpha, eval)
                    if beta <= alpha:
                        break  # Alpha-beta pruning
            return max_eval
        else:
            min_eval = float('inf')
            pieces = self.game.get_player_pieces(self.opponent_color)
            for x, y in pieces:
                moves = board.get_valid_legal_moves(x, y, False)
                for move in moves:
                    new_board = deepcopy(board)
                    self._make_move(new_board, (x, y), move)
                    eval = self._minimax(new_board, depth - 1, True, alpha, beta)
                    min_eval = min(min_eval, eval)
                    beta = min(beta, eval)
                    if beta <= alpha:
                        break  # Alpha-beta pruning
            return min_eval

    def _evaluate_board(self, board):
        """Evaluate the board position for the AI"""
        score = 0
        for y in range(8):
            for x in range(8):
                piece = board.getSquare(x, y).squarePiece
                if piece:
                    # Kings are worth more than regular pieces
                    value = 1 + (piece.king * 0.5)
                    if piece.color == self.color:
                        score += value
                    else:
                        score -= value
        return score

    def _make_move(self, board, from_pos, to_pos):
        """Make a move on the board"""
        fx, fy = from_pos
        tx, ty = to_pos
        piece = board.getSquare(fx, fy).squarePiece
        board.getSquare(fx, fy).squarePiece = None
        board.getSquare(tx, ty).squarePiece = piece

        # Handle captures
        if abs(tx - fx) == 2:  # Capture move
            captured_x = (fx + tx) // 2
            captured_y = (fy + ty) // 2
            board.getSquare(captured_x, captured_y).squarePiece = None

        # Handle king promotion
        if (ty == 0 and piece.color == PLAYER2) or (ty == 7 and piece.color == PLAYER1):
            piece.king = True

"""# Main Game Loop"""

# Main function to run the game
def main():
    game = Game()
    smart_ai = SmartAI(PLAYER1, game)  # Red player (Smart AI)
    random_ai = RandomAI(PLAYER2, game)  # Blue player (Random AI)

    # Show game start popup and header
    popup("The match will be played now!")
    display(HTML("<h3>Starting AI vs AI Checkers Game</h3>"))
    display(HTML("<p><span style='color:red'>Red: Smart AI (Minimax)</span> vs <span style='color:blue'>Blue: Random AI</span></p>"))
    print_board(game.board)

    # Main game loop
    while not game.is_game_over():
        # Determine current player
        current_ai = smart_ai if game.current_turn == PLAYER1 else random_ai
        move = current_ai.get_move(game.board)

        if move:
            from_pos, to_pos = move
            color_text = "red" if game.current_turn == PLAYER1 else "blue"
            player_text = "Red" if game.current_turn == PLAYER1 else "Blue"
            display(HTML(f"<p>Move {game.move_count + 1}: <span style='color:{color_text}'>{player_text}</span> moves from {from_pos} to {to_pos}</p>"))
            current_ai._make_move(game.board, from_pos, to_pos)
            print_board(game.board)
        else:
            color_text = "red" if game.current_turn == PLAYER1 else "blue"
            player_text = "Red" if game.current_turn == PLAYER1 else "Blue"
            display(HTML(f"<p><span style='color:{color_text}'>{player_text}</span> has no valid moves!</p>"))
            break

        game.end_turn()
        time.sleep(0.5)  # Add delay to make the game more viewable

    # Show game over message
    display(HTML("<h3>Game Over!</h3>"))
    popup(game.get_winner())
    display(HTML(f"<p>{game.get_winner()}</p>"))

"""# Opponest AI (You can add your code for Competitation)"""

# Define the Random AI player that makes random legal moves
class RandomAI:
    def __init__(self, color, game):
        self.color = color
        self.game = game

    def get_move(self, board):
        """Get a random valid move for the AI"""
        pieces = self.game.get_player_pieces(self.color)
        random.shuffle(pieces)

        # Find the first piece with valid moves
        for x, y in pieces:
            moves = board.get_valid_legal_moves(x, y, False)
            if moves:
                return ((x, y), random.choice(moves))
        return None

    def _make_move(self, board, from_pos, to_pos):
        """Make a move on the board"""
        fx, fy = from_pos
        tx, ty = to_pos
        piece = board.getSquare(fx, fy).squarePiece
        board.getSquare(fx, fy).squarePiece = None
        board.getSquare(tx, ty).squarePiece = piece

        # Handle captures
        if abs(tx - fx) == 2:  # Capture move
            captured_x = (fx + tx) // 2
            captured_y = (fy + ty) // 2
            board.getSquare(captured_x, captured_y).squarePiece = None

        # Handle king promotion
        if (ty == 0 and piece.color == PLAYER2) or (ty == 7 and piece.color == PLAYER1):
            piece.king = True

"""# Run the GAME"""

# Run the game
if __name__ == "__main__":
    main()

